package com.rubu.ui.act;

import android.graphics.drawable.Drawable;
import android.os.Handler;
import android.os.Message;
import android.text.Html;
import android.text.method.LinkMovementMethod;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.rubu.R;
import com.rubu.base.BaseActivity;
import com.rubu.constant.Constant;
import com.rubu.model.MsgDetailModel;
import com.rubu.net.ApiImp;
import com.rubu.net.Params;
import com.rubu.net.ReqJson;
import com.rubu.util.LoginUtil;

import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;

import butterknife.BindView;
import rx.Observer;
import rx.android.schedulers.AndroidSchedulers;
import rx.schedulers.Schedulers;

/**
 * Created by liuhaizhu on 2017/3/6.
 */

public class MsgDetailAct extends BaseActivity {
    @BindView(R.id.title_left)
    TextView mTitleLeft;
    @BindView(R.id.title)
    TextView mTitle;
    @BindView(R.id.tv_title)
    TextView mTvTitle;
    @BindView(R.id.tv_time)
    TextView mTvTime;
    @BindView(R.id.userName)
    TextView mTvUserName;
    @BindView(R.id.tv_content)
    TextView mTvContent;

    private int msg_id;

    private Drawable drawable;
    private String ncontent;

    @Override
    protected int getViewId() {
        return R.layout.act_msg_detail;
    }

    @Override
    protected void initEvent() {
        msg_id = getIntent().getIntExtra("msgId", 0);
        mTitleLeft.setText(R.string.back);
        mTitleLeft.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                onBackPressed();
            }
        });
        mTitle.setText("消息");
        getMsg();
    }

    private void getMsg() {
        showProgressDialog("详情获取中");
        final ReqJson reqJson = new ReqJson();
        reqJson.setProc(Constant.PROC_GET_MSG_DETIAL);
        reqJson.setMsg_id(String.valueOf(msg_id));
        reqJson.setUser_id(LoginUtil.getUserId(mContext));
        reqJson.setHas_rows("yes");
        mSubscription = ApiImp.get().getMsgDetail(Params.getNetWorkParams(reqJson))
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Observer<MsgDetailModel>() {
                    @Override
                    public void onCompleted() {
                    }

                    @Override
                    public void onError(Throwable e) {
                        dissmisProgressDialog();
                        finish();
                        showToast("网络不给力");
                    }

                    @Override
                    public void onNext(MsgDetailModel model) {
                        dissmisProgressDialog();
                        MsgDetailModel.RowsBean rowsBean = model.getRows().get(0);
//                        mTvContent.setText("\u3000\u3000"+rowsBean.getMsg_content());
                        ncontent = rowsBean.getMsg_content();
                        if (ncontent.contains("<img src=") || ncontent.contains("src=")) {
                            bindData();
                        } else {
                            mTvContent.setText("\u3000\u3000" + Html.fromHtml(ncontent));
                        }
                        mTvTitle.setText(rowsBean.getMsg_title());
                        mTvUserName.setText(rowsBean.getUser_name());
                        mTvTime.setText(rowsBean.getModify_time());
                    }
                });

    }

    //    开线程不断下载接收图片
    Handler mHandler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(Message msg) {
            if (msg.what == 0x101) {
                if (drawable == null) {
                    bindData();
                    return false;
                }
                if (ncontent != null) {
                    mTvContent.setText((CharSequence) msg.obj);
                    mTvContent.setClickable(true);
                    mTvContent.setMovementMethod(LinkMovementMethod.getInstance());
                }
            }
            return false;
        }
    });

    private void bindData() {
        new Thread(new Runnable() {
            Message msg = Message.obtain();

            @Override
            public void run() {
                Html.ImageGetter imageGetter = new Html.ImageGetter() {
                    @Override
                    public Drawable getDrawable(String source) {
                        if (source.substring(0, 8).equals("/Content")) {
                            source = Constant.BASE_URL + source;
                        }
                        drawable = getImageFromNetwork(source);
                        if (drawable != null) {
//                            drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());
                            drawable.setBounds(10, 10, 800, 1200);
                        } else if (drawable == null) {
                            //bindData();
                            return null;
                        }
                        return drawable;
                    }
                };
                //Spanned spanned = Html.fromHtml(ncontent, imageGetter, null);
                CharSequence charSequence = Html.fromHtml(ncontent, imageGetter, null);
                msg.what = 0x101;
                msg.obj = charSequence;
                if (mHandler != null) {
                    mHandler.sendMessage(msg);
                }

            }
        }).start();

    }

    /**
     * @param imageUrl
     * @return
     */
    public Drawable getImageFromNetwork(String imageUrl) {
        URL myFileUrl = null;
        Drawable drawable = null;
        try {
            myFileUrl = new URL(imageUrl);
            HttpURLConnection conn = (HttpURLConnection) myFileUrl
                    .openConnection();
            conn.setDoInput(true);

            conn.connect();
            InputStream is = conn.getInputStream();
            drawable = Drawable.createFromStream(is, null);
            is.close();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        return drawable;
    }

}
