package com.rubu.util;

import android.app.DownloadManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.support.v4.content.FileProvider;
import android.text.TextUtils;
import android.view.View;
import android.widget.Toast;

import com.rubu.R;
import com.rubu.constant.Constant;
import com.rubu.model.VersionModel;
import com.rubu.pop.dialog.MyAlertDialog;

import java.io.File;


/**
 * 版本更新apk下载安装
 */
public class UpdateUtils {

    /**
     * @param context
     * @param bean      版本更新对象
     * @param infoState
     */
    public static void alertDownload(final Context context, VersionModel.RowsBean bean, final int infoState) {
        final String url = bean.getUrl();
        final String versionShort = bean.getVersion();
        final String updateReason = versionShort + " : " + bean.getUpdate_reason();
        String is_force = bean.getIs_force();
        DownloadManager downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);
        if (isDownloading(downloadManager, url)) {
            Toast.makeText(context, "更新正在下载，请稍后重试", Toast.LENGTH_SHORT).show();
            return;
        }
        // 版本更新的新弹框;
        final MyAlertDialog myDialog = new MyAlertDialog.Builder(context)
                .setContentView(R.layout.pop_update_force)
                .setCancelable(false)
                .setText(R.id.update_reson, updateReason)
                .show();
        myDialog.setClick(R.id.confirm, new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //判断DownloadManager是否可用，如果不可用就调用系统浏览器更新
                if (!canDownloadState(context)) {
                    myDialog.dismiss();
                    Intent intent = new Intent();
                    intent.setAction("android.intent.action.VIEW");
                    Uri content_url = Uri.parse(url);
                    intent.setData(content_url);
                    context.startActivity(intent);
                } else {
                    myDialog.dismiss();
                    startDownload(context, url, versionShort);
                }

            }
        });
        if ("N".equals(is_force)) {
            myDialog.setVisibility(R.id.cancel, View.VISIBLE);
            myDialog.setClick(R.id.cancel, new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    myDialog.dismiss();
                }
            });
        }
    }

    /**
     * 提示下载app
     *
     * @param context
     * @param url
     * @param versionShort
     */
    public static void startDownload(Context context, String url, String versionShort) {
        DownloadManager downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);
        DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));

        PackageManager pm = context.getPackageManager();
        ApplicationInfo info = null;
        String appName = Constant.APPLICATION_ID;
        try {
            info = pm.getApplicationInfo(context.getPackageName(), 0);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }

        if (info != null) {
            appName = context.getString(info.labelRes);
        }
        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
        request.setTitle(appName);
        request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS,
                Constant.APPLICATION_ID.replace(".", "_") + "_" + versionShort + ".apk");
        request.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI
                | DownloadManager.Request.NETWORK_MOBILE);

        long downloadId = downloadManager.enqueue(request);
        IntentFilter filter = new IntentFilter();
        filter.addAction("android.intent.action.DOWNLOAD_COMPLETE");
        SystemReceiver receiver = new SystemReceiver(downloadId);
        context.registerReceiver(receiver, filter);
    }

    /**
     * 是否正在下载
     *
     * @return
     */
    public static boolean isDownloading(DownloadManager downloadManager, String url) {
        DownloadManager.Query query = new DownloadManager.Query();
        query.setFilterByStatus(DownloadManager.STATUS_RUNNING | DownloadManager.STATUS_PAUSED);
        Cursor cursor = downloadManager.query(query);
        while (cursor.moveToNext()) {
            String localUrl = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_URI));
            if (TextUtils.equals(localUrl, url)) {
                return true;
            }
        }
        return false;
    }


    /**
     * 提示下载完成
     *
     * @param downloadManager 下载服务管理器
     * @param url             下载存储的地址
     * @return
     */
    public static String isDownloadCompleted(DownloadManager downloadManager, String url) {
        DownloadManager.Query query = new DownloadManager.Query();
        query.setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL);
        Cursor cursor = downloadManager.query(query);
        while (cursor.moveToNext()) {
            String filename = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME));
            String localUrl = cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_URI));
            File apkFile = new File(filename);
            if (TextUtils.equals(localUrl, url) && !TextUtils.isEmpty(filename)
                    && apkFile.exists()) {
                return filename;
            }
        }
        return null;
    }

    /**
     * 监听下载完成
     */
    public static class SystemReceiver extends BroadcastReceiver {

        private long cDownloadId;

        public SystemReceiver(long cDownloadId) {
            this.cDownloadId = cDownloadId;
        }


        @Override
        public void onReceive(Context context, Intent intent) {
            DownloadManager downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);
            long downloadId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0);
            if (cDownloadId == downloadId) {
                DownloadManager.Query query = new DownloadManager.Query();
                query.setFilterById(downloadId);

                Cursor cursor = downloadManager.query(query);
                if (cursor.moveToFirst()) {
                    int status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));
                    switch (status) {
                        case DownloadManager.STATUS_SUCCESSFUL:
                            //如果文件名不为空，说明已经存在了，然后获取uri，进行安装
//                            File path = new File(cursor.getString(cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME)));
                            int fileUriIdx = cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI);
                            String fileUri = cursor.getString(fileUriIdx);
                            String fileName = null;
                            if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                                if (fileUri != null) {
                                    fileName = Uri.parse(fileUri).getPath();
                                }
                            } else {
                                //Android 7.0以上的方式：请求获取写入权限，这一步报错
                                //过时的方式：DownloadManager.COLUMN_LOCAL_FILENAME
                                int fileNameIdx = cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENAME);
                                fileName = cursor.getString(fileNameIdx);
                            }
                            File path = new File(fileName);
                            if (!path.exists()) {
                                return;
                            }
//                            Uri uri = Uri.fromFile(path);
                            Intent install = new Intent(Intent.ACTION_VIEW);
                            if (Build.VERSION.SDK_INT >= 24) {
                                Uri uri = FileProvider.getUriForFile(context, "com.jph.takephoto.rubukeji", path);
                                install.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_ACTIVITY_NEW_TASK);
                                install.setDataAndType(uri, "application/vnd.android.package-archive");
                            } else {
                                Uri uri = Uri.fromFile(path);
                                install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                                install.setDataAndType(uri, "application/vnd.android.package-archive");
                            }
                            // 执行意图进行安装
                            context.startActivity(install);
                            break;
                        default:
                            downloadManager.remove(downloadId);
                            break;
                    }
                }
            }
            context.unregisterReceiver(this);
        }
    }

    /**
     * 判断DownloadManager是否可以用
     */
    private static boolean canDownloadState(Context ctx) {
        try {
            int state = ctx.getPackageManager().getApplicationEnabledSetting("com.android.providers.downloads");

            if (state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED
                    || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER
                    || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {
                return false;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

}
